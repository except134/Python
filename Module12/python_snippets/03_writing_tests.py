# -*- coding: utf-8 -*-


# Как писать тесты в пайтоне?

# Большая программа на пайтоне - всегда набор модулей/пакетов.
# Тесты обычно содержатся в отдельном модуле/пакете.
# Модули тестов должны начинаться со слова test_
# Такое соглашение помогает unittest автоматически их находить.

# План действий с сортировкой:
#   сначала рефакторим с отладкой
#   меняем условия заказчика: необходимо что бы одинаковые значения
#                             выводились всего один раз
#       модифицируем тесты под новое задание
#   еще раз рефакторим


# А как тестировать сложное?

#   создать тестируемый обьект и все что нужно ему для работы
#   задать начальные условия
#   запустить тестируемый метод
#   посмотреть что получилось

# У unittest.TestCase есть метод setUp, он вызывается перед КАЖДЫМ тестом,
# туда можно вынести первые два пункта.

# Для функциональных тестов - практически то же самое, но:
#   можно запускать не один метод тестируемого обьекта
#   проверок нужно больше


# А что делать, если есть нечто, от программиста не зависящее?
# Скажем, внешние данные, которые сложно достать/они могут быть недоступны.
#
# С мощью пайтон это не проблема - можно делать имитации и патчить ими код.
# Как? см lesson_014/python_snippets/tests/test_handling_external_data.py
# Программист может зафиксировать (зафризить на сленге)
# поведение внешних источников данных.

# Для упрощения этого процесса есть отличная библиотека - unittest.mock
# Которая позволяет делать mock-обьекты (от англ. mock object, буквально:
# «объект-пародия», «объект-имитация», а также «подставка»)

from unittest.mock import Mock

fake_1 = Mock()
print(fake_1)
print(fake_1())

print(fake_1(1, 2, 3, test=42))
print(fake_1.called)  # вызывался ли объект вообще
print(fake_1(test=42))
print(fake_1.call_count)  # количество вызовов
print(fake_1.call_args)  # аргументы последнего вызова
fake_1.assert_called_with(test=42)

# можно задать что должен возвращать обьект-пустышка
fake_2 = Mock(return_value=42)
print(fake_2())

# мок-обьект имеет произвольные атрибуты - они тоже мок-обьекты
fake_3 = Mock()
print(fake_3.nonexistent_attr)
fake_3.any_attr = 27
print(fake_3.any_attr)

fake_4 = Mock(return_value=fake_3)
result = fake_4()
print(result.any_attr)

# более подробно про все возможности mock-обьектов можно почитать в доках
# https://docs.python.org/3/library/unittest.mock.html
# и в интернете https://goo.gl/Vcb7y2


# Подведем итоги.

# Недостатки тестов:
#   - им нужно уделять время: писать их.
#   - в процессе развития программы нужно обновлять тесты и писать новые.

# Преимущества тестов:
#   - можно отдавать код на доработку другим программистам, тесты гарантируют что ничего не сломается
#   - можно рефакторить/улучшать код, тесты гарантируют что ничего не сломается
#   - можно портировать ПО на разные платформы, тесты гарантируют что ничего не сломается

# Преимущества в переспективе с лихвой перекрывают недостатки.
# Поэтому писать тесты - просто необходимо!
