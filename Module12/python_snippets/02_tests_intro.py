# -*- coding: utf-8 -*-

# Что есть тесты и зачем они нужны?

# Предположим что у нам задали задание - написать функцию сортировки списка.
# (для пайтона это нонсенс, но мы - в обучающих целях)
# Берем любимый/простой метод пузырька и кодим его.


def my_sort(slist):
    was_swap = True
    while was_swap:
        was_swap = False
        for i in range(len(slist) - 1):
            if slist[i] > slist[i + 1]:
                slist[i], slist[i + 1] = slist[i + 1], slist[i]
                was_swap = True
    return slist


# а потом проверяем с разными данными
print(my_sort([3, 4, 2, 8, 1, 6, 4]))
print(my_sort([3, 4, 5]))
print(my_sort([3, 2, 1]))
print(my_sort([]))
print(my_sort([9, 3, -7, 2]))

# и каждый раз при дорабоке кода нам нужно запускать функцию
# и ВИЗУАЛЬНО/руками (!!!) проверять, что она правильно сработала... :(((
# ужас, сколько работы :(((
# Программисты - народ ленивый. Давайте автоматизируем!


if my_sort([3, 4, 2, 8, 1, 6, 4]) != [1, 2, 3, 4, 4, 6, 8]:
    print('Ошибка!')
if my_sort([3, 4, 5]) != [3, 4, 5]:
    print('Ошибка!')
if my_sort([3, 2, 1]) != [1, 2, 3]:
    print('Ошибка!')
if my_sort([]) != []:
    print('Ошибка!')
if my_sort([9, 3, -7, 2]) != [-7, 2, 3, 9]:
    print('Ошибка!')

# Уже лучше. Программисты поняли что это - золотая жила и сделали специальный
# оператор assert - англ. "утверждение"
assert my_sort([3, 4, 2, 8, 1, 6, 4]) == [1, 2, 3, 4, 4, 6, 8]

# можно еще писать сообщение, детализирующее возможную ошибку
assert my_sort([3, 4, 2, 8, 1, 6, 4]) == [1, 2, 3, 4, 4, 6, 8], 'не работает сортировка целых положительных'


# Стоит упомянуть о специфичном для пайтона виде тестов - doc-тесты:
# тесты, хранящиеся в doc-строках функций
def my_sort(slist):
    """
    Функция сортировки списков

    >>> my_sort([3,2,1])
    [1, 2, 3]
    """
    was_swap = True
    while was_swap:
        was_swap = False
        for i in range(len(slist) - 1):
            if slist[i] > slist[i + 1]:
                slist[i], slist[i + 1] = slist[i + 1], slist[i]
                was_swap = True
    return slist


if __name__ == "__main__":
    import doctest
    doctest.testmod()

# Видно что док-тесты очень просты, фактически assert.
# Но зато можно быстро скопировать из командной строки.
# Иногда помогают в простейших случаях, в остальных случаях - лучше не использовать.

# assert-ы и doc-тесты - очень простые, буквально одно сравнение.
# А если нужно протестировать сложные програмные проекты в сложных условиях?
# Программисты позаботились о себе и написали специальные модули,
# которые помогают писать сложные тесты-проверки

import unittest


class MySortTest(unittest.TestCase):
    # нужно отнаследоваться от этого класса, что бы заработала магия тестирования

    # проверяющие методы должны начинаться с test_
    def test_normal(self):
        # запускаем тестируемую функцию
        result = my_sort([3, 4, 2, 8, 1, 6, 4])
        # проверяем что она вернула
        self.assertEqual(result, [1, 2, 3, 4, 4, 6, 8])

    # в именах методов-проверок очень желательно указывать
    # какой вариант они проверяют
    def test_sorted(self):
        result = my_sort([3, 4, 5])
        # так же можно писать детализирующее сообщение
        self.assertEqual(result, [3, 4, 5], 'не работает сортировка отсортированного списка')

    # и так далее - записываем все возможные случаи
    def test_reversed(self):
        result = my_sort([3, 2, 1])
        self.assertEqual(result, [1, 2, 3])

    def test_empty(self):
        result = my_sort([])
        self.assertEqual(result, [])

    def test_with_negative(self):
        result = my_sort([9, 3, -7, 2])
        self.assertEqual(result, [-7, 2, 3, 9])


if __name__ == '__main__':
    # запускам автодискавер тестов
    unittest.main()

# Если тест падает, то будет достаточно говоряшее сообщение об ошибке
# И да, имя теста - помогает!
# Таким образом можно автоматизировать проверки написанного кода.
# И в промышленном программированиии тесты неотьемлемая часть програмного продукта.

# Рассмотрим Виды тестов.
#
# Теории тут много https://goo.gl/E1hzF8 - можете почитать на досуге.
# Выделю основное (по моему мнению): от простых тестов к сложным.
#
# Смоук (smoke) тесты - "все горит" тесты:
#   тестируем, что программа запускается / модуль импортируется без ошибок в консоли.
#
# Модульные тесты (unit тесты):
#   тестируются отдельные функции или методы классов.
#
# Функциональные тесты:
#   проверяется, соответствует ли программа техзаданию
#
# Регрессионные тесты
#   проверяется, что найденные ранее ошибки больше не повторяются
#
# Интеграционные тесты:
#   проверяется как взаимодействуют разные компоненты больших программынх комплексов
#   возможно написанные на разных языках
#
# Нагрузочные тесты:
#   проверяется как ведет себя программа/сервер под множеством одновренменных запросов

# Далее мы будем рассматривать юнит и функциональные тесты.
